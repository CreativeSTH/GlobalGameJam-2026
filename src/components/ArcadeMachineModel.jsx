/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from 'react';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { useGLTF, Environment, Float } from '@react-three/drei';

function Model({ scrollProgress, ...props }) {
  const { nodes, materials } = useGLTF('/3d/arcade_high.glb');
  const group = useRef();
  const { viewport } = useThree();

  useFrame((state) => {
    if (group.current) {
      // Base rotation (No ambient spin)
      // User requested 160 degrees offset to fix orientation
      let targetRotationY = 160 * (Math.PI / 180);

      // Add scroll influence if available
      if (scrollProgress) {
        // Get current scroll value (0 to 1)
        const currentScroll = scrollProgress.get();

        // ROTATION:
        targetRotationY += currentScroll * Math.PI * 4;

        // POSITION (Arc Movement):
        // X: Linear movement from Left (-35% viewport) to Right (+35% viewport)
        const x = (currentScroll - 0.5) * (viewport.width * 0.7);

        // Y: Parabolic arc with lower end
        // Start at -30%, End at -60% (Lower)
        const startY = -viewport.height * 0.3;
        const endY = -viewport.height * 0.6;
        // Linear interpolation of the baseline
        const currentBaseY = startY + (endY - startY) * currentScroll;

        const peakHeight = viewport.height * 0.4;
        const y = currentBaseY + Math.sin(currentScroll * Math.PI) * peakHeight;

        group.current.position.set(x, y, 0);

        // SCALE:
        // Grow from base scale
        const baseScale = 35;
        const scale = baseScale * (1 + currentScroll * 1.5);
        group.current.scale.setScalar(scale);
      }

      // Apply rotation smoothly
      group.current.rotation.y = targetRotationY;

      // No ambient tilt
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      {/* Inner group from gltfjsx with Original transforms */}
      <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <mesh geometry={nodes.ArcadeLow_Button_A.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.ArcadeLow_Button_B.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.ArcadeLow_Button_C.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.ArcadeLow_Button_D.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.ArcadeLow_Button_E.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.ArcadeLow_Button_F.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.ArcadeLow_Button_G.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.ArcadeLow_Button_H.geometry} material={materials['standardSurface1.1002']} />

        {/* Custom Glass Material - Adjusted for Clarity */}
        <mesh geometry={nodes.ArcadeLow_Glass.geometry}>
          <meshPhysicalMaterial
            color="#ffffff"
            roughness={0}
            metalness={0.1}
            transmission={0.99} // High transmission for clarity
            transparent={true} // Enable transparency
            opacity={0.1} // Very low opacity to avoid "milky" look
            thickness={0} // Thin glass
            ior={1.5}
            clearcoat={1} // Add clearcoat for extra shine
            clearcoatRoughness={0}
          />
        </mesh>

        <mesh geometry={nodes.ArcadeLow_Screen.geometry} material={materials['standardSurface1.1002']} position={[0, -0.038, 0]} />
        <mesh geometry={nodes.Mesh.geometry} material={materials['standardSurface1.1001']} />
        <mesh geometry={nodes.Mesh_1.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.Mesh003.geometry} material={materials['standardSurface1.1001']} />
        <mesh geometry={nodes.Mesh003_1.geometry} material={materials['standardSurface1.1002']} />
        <mesh geometry={nodes.Mesh004.geometry} material={materials['standardSurface1.1001']} />
        <mesh geometry={nodes.Mesh004_1.geometry} material={materials['standardSurface1.1002']} />
      </group>
    </group>
  );
}

useGLTF.preload('/3d/arcade_high.glb');

export default function ArcadeMachineModel({ scrollProgress, className = "w-full h-full" }) {
  return (
    <div className={className}>
      <Canvas camera={{ position: [0, 0, 10], fov: 45 }} gl={{ alpha: true }}>
        <ambientLight intensity={1} />
        <spotLight position={[10, 10, 10]} angle={0.5} penumbra={1} intensity={2} color="#ffffff" />
        <pointLight position={[-10, -10, -10]} intensity={2} color="#3b82f6" />

        <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
          <Model scrollProgress={scrollProgress} />
        </Float>

        <Environment preset="city" />
      </Canvas>
    </div>
  );
}
